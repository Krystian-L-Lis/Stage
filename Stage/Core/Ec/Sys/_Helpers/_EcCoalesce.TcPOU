<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="_EcCoalesce" Id="{a924f6c7-e6ef-4406-aeaa-0bab42ee8da3}" SpecialFunc="None">
    <Declaration><![CDATA[// ---------------------------------------------------------------------------
// FUNCTION:  _EcCoalesce
// PURPOSE:   Compacts (coalesces) all occupied blocks in _Ec.comp[] to the
//            left, removing any gaps between them. Updates each entity's
//            _Start and _End accordingly, zeroes out remaining slots,
//            and reassigns _Ec.iFirst to the new leftmost entity, if any.
// ---------------------------------------------------------------------------
FUNCTION _EcCoalesce : Result
VAR
    i             : UDINT;
    _nStartIndex  : UDINT;      // Not used in this version, but declared
    _nSlotsMoved  : UDINT;
    _nNextMove    : UDINT := 1; // Destination pointer for the next block
    _nChunkSize   : UDINT;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[// 1) If we are at maximum capacity (all slots are allocated).
IF _Ec.nCompLen = Param.ENTITY_CAP THEN
    _EcCoalesce := Err.Ovf;
    RETURN;
END_IF

// 2) If there are no allocated slots at all, nothing to coalesce.
IF _Ec.nCompLen = 0 THEN
    _EcCoalesce := Ok;
    RETURN;
END_IF

// 3) Single pass from slot 1 to Param.ENTITY_CAP
FOR i := 1 TO Param.ENTITY_CAP DO

    // Stop early if we've already repositioned all allocated slots
    IF _nSlotsMoved = _Ec.nCompLen THEN
        EXIT;
    END_IF

    CASE _Ec.comp[i].nType OF
        
        0:
            // FREE slot => do nothing, just keep scanning.
            
        1:
            // This indicates the start (or within) an occupied block.
            // We'll treat this as the start of the block:
            _nChunkSize := _Ec.comp[i].iObj.iEntity.Size;
            
            // If the block is not already at _nNextMove, we move it.
            IF i <> _nNextMove THEN
                
                // Move the entire block at once:
                Tc2_System.MEMMOVE(
                    ADR(_Ec.comp[_nNextMove]),  // Destination
                    ADR(_Ec.comp[i]),           // Source
                    SIZEOF(ST_EcObject) * _nChunkSize
                );
                
                // Update the entity's _Start/_End in the new location.
                _Ec.comp[_nNextMove].iObj.iEntity._Start := _nNextMove;
                _Ec.comp[_nNextMove].iObj.iEntity._End   := _nNextMove + _nChunkSize - 1;
                
                // Optionally, clear the old region here if desired.
            END_IF

            // Increase the “moved” counter by the size of this block (in slots).
            _nSlotsMoved := _nSlotsMoved + _nChunkSize;
            
            // Advance _nNextMove so the next block can be placed after this one.
            _nNextMove := _nNextMove + _nChunkSize;
            
            // Jump over the rest of this block in the FOR loop.
            i := i + _nChunkSize - 1;  // net effect: next iteration is i + _nChunkSize

        ELSE
            // Invalid slot type => internal error or corrupted data
            _EcCoalesce := Err.IncArg;
            RETURN;

    END_CASE
END_FOR

// 4) By here, we've repositioned all occupied slots to the left side
//    up to index (_nNextMove - 1). Everything from _nNextMove..Param.ENTITY_CAP
//    can be cleared to FREE (nType=0, or zero out everything).
Tc2_System.MEMSET(
    ADR(_Ec.comp[_nNextMove]), // Start clearing right after the last block
    0,
    SIZEOF(ST_EcObject) * (Param.ENTITY_CAP - (_nNextMove - 1))
);

// 5) Update _Ec.iFirst if we have at least one block.
//    The leftmost block is now at index 1.
IF _Ec.comp[1].nType = 1 THEN
    // Set iFirst to the new first entity
    _Ec.iFirst := _Ec.comp[1].iObj.iEntity;
    _EcCoalesce := Ok;
ELSE
    // If for some reason index 1 is still free, consider it an internal error
    _EcCoalesce := Err.IncArg;
END_IF]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>